<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="什么是进程？什么是线程？ 进程是一个应用程序。  线程是一个进程中的执行场景、执行单元。一个进程可以启动多个线程  对于Java程序来说，当在DOS命令窗口输入：java Hello World回车之后，会先启动JVM，而JVM就是一个进程。JVM再启动一个主线程调用main方法。同时再启动一个垃圾回收线程负责看护，回收垃圾。  使用了多线程机制之后，main方法结束，是不是有可能程序也不会结束。">
<meta property="og:type" content="article">
<meta property="og:title" content="40、Java 多线程">
<meta property="og:url" content="http://www.ctong.top/2022/01/02/40%E3%80%81Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="Clover Blog">
<meta property="og:description" content="什么是进程？什么是线程？ 进程是一个应用程序。  线程是一个进程中的执行场景、执行单元。一个进程可以启动多个线程  对于Java程序来说，当在DOS命令窗口输入：java Hello World回车之后，会先启动JVM，而JVM就是一个进程。JVM再启动一个主线程调用main方法。同时再启动一个垃圾回收线程负责看护，回收垃圾。  使用了多线程机制之后，main方法结束，是不是有可能程序也不会结束。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://qiniu-note-image.ctong.top/note/images/image-fcc7160104824cb5b20facbca02b58b5.png">
<meta property="og:image" content="http://qiniu-note-image.ctong.top/note/images/image-428c0fc525a94f668b2a9c194cfeba81.png">
<meta property="og:image" content="http://qiniu-note-image.ctong.top/note/images/image-faad6930b5514002a557978eae51425e.png">
<meta property="og:image" content="http://qiniu-note-image.ctong.top/note/images/image-17bec6a0476d4ec8ac96e6a1c300d90d.png">
<meta property="og:image" content="http://qiniu-note-image.ctong.top/note/images/image-ac178fc547e84b62a87a0930a88cd6b0.png">
<meta property="og:image" content="http://qiniu-note-image.ctong.top/note/images/image-ac178fc547e84b62a87a0930a88cd6b0-20211227102835587.png">
<meta property="og:image" content="http://qiniu-note-image.ctong.top/note/images/image-ffd3735a179643adb0831bdf779b1f11.png">
<meta property="og:image" content="http://qiniu-note-image.ctong.top/note/images/image-1b76c2ef7b0a43c5bb7e1e814cb23ec1.png">
<meta property="article:published_time" content="2022-01-02T09:19:00.000Z">
<meta property="article:modified_time" content="2023-05-26T09:45:32.842Z">
<meta property="article:author" content="Clover You">
<meta property="article:tag" content="JAVA">
<meta property="article:tag" content="学习笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://qiniu-note-image.ctong.top/note/images/image-fcc7160104824cb5b20facbca02b58b5.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>40、Java 多线程</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="Clover Blog" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2022/01/02/41%E3%80%81%E5%85%B3%E4%BA%8Ejava%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2022/01/02/39%E3%80%81IO%E5%92%8CProperties%E7%9A%84%E8%81%94%E5%90%88%E4%BD%BF%E7%94%A8/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://www.ctong.top/2022/01/02/40%E3%80%81Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://www.ctong.top/2022/01/02/40%E3%80%81Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/&text=40、Java 多线程"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://www.ctong.top/2022/01/02/40%E3%80%81Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/&title=40、Java 多线程"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://www.ctong.top/2022/01/02/40%E3%80%81Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/&is_video=false&description=40、Java 多线程"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=40、Java 多线程&body=Check out this article: http://www.ctong.top/2022/01/02/40%E3%80%81Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://www.ctong.top/2022/01/02/40%E3%80%81Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/&title=40、Java 多线程"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://www.ctong.top/2022/01/02/40%E3%80%81Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/&title=40、Java 多线程"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://www.ctong.top/2022/01/02/40%E3%80%81Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/&title=40、Java 多线程"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://www.ctong.top/2022/01/02/40%E3%80%81Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/&title=40、Java 多线程"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://www.ctong.top/2022/01/02/40%E3%80%81Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/&name=40、Java 多线程&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://www.ctong.top/2022/01/02/40%E3%80%81Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/&t=40、Java 多线程"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">什么是进程？什么是线程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">2.1.</span> <span class="toc-text">第一种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">第二种方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.</span> <span class="toc-text">线程生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8B%E5%AF%B9%E8%B1%A1%E5%90%8D%E5%AD%97"><span class="toc-number">4.</span> <span class="toc-text">获取线程对象名字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.</span> <span class="toc-text">获取当前线程对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84sleep%E6%96%B9%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">线程的sleep方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%9D%A1%E7%9C%A0"><span class="toc-number">7.</span> <span class="toc-text">终止线程的睡眠</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#interrupt"><span class="toc-number">7.1.</span> <span class="toc-text">interrupt</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stop"><span class="toc-number">7.2.</span> <span class="toc-text">stop</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A6%82%E8%BF%B0"><span class="toc-number">8.</span> <span class="toc-text">线程调度概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">8.1.</span> <span class="toc-text">线程优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%AE%A9%E4%BD%8D"><span class="toc-number">8.2.</span> <span class="toc-text">线程让位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E7%BA%BF%E7%A8%8B"><span class="toc-number">8.3.</span> <span class="toc-text">合并线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">9.</span> <span class="toc-text">线程安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized-%E5%85%B3%E9%94%AE%E5%AD%97-%E2%80%93-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">9.1.</span> <span class="toc-text">synchronized 关键字 – 线程同步机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81"><span class="toc-number">10.</span> <span class="toc-text">线程死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%AE%80%E5%8D%95%E4%BB%A3%E7%A0%81"><span class="toc-number">10.1.</span> <span class="toc-text">死锁简单代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">10.2.</span> <span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9"><span class="toc-number">11.</span> <span class="toc-text">线程相关内容</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">11.0.1.</span> <span class="toc-text">守护线程的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E7%94%A8%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9%E5%91%A2%EF%BC%9F"><span class="toc-number">11.0.2.</span> <span class="toc-text">守护线程用在什么地方呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-number">11.0.3.</span> <span class="toc-text">设置守护线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">11.0.4.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AC%AC%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">11.0.5.</span> <span class="toc-text">实现线程的第三种方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">11.1.</span> <span class="toc-text">生产者和消费者</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        40、Java 多线程
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">Clover You</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2022-01-02T09:19:00.000Z" class="dt-published" itemprop="datePublished">2022-01-02</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/Java-%E5%9F%BA%E7%A1%80/">Java 基础</a>
    </div>


      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/JAVA/" rel="tag">JAVA</a>, <a class="p-category" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h2 id="什么是进程？什么是线程？"><a href="#什么是进程？什么是线程？" class="headerlink" title="什么是进程？什么是线程？"></a>什么是进程？什么是线程？</h2><ol>
<li><p>进程是一个应用程序。</p>
</li>
<li><p>线程是一个进程中的执行场景、执行单元。一个进程可以启动多个线程</p>
</li>
<li><p>对于Java程序来说，当在DOS命令窗口输入：java Hello World回车之后，会先启动JVM，而JVM就是一个进程。JVM再启动一个主线程调用main方法。同时再启动一个垃圾回收线程负责看护，回收垃圾。</p>
</li>
<li><p>使用了多线程机制之后，main方法结束，是不是有可能程序也不会结束。main方法结束只是主线程结束了，主栈空了，其它的栈（线程）可能还在压栈弹栈。</p>
<blockquote>
<p>进程A和进程B的内存独立不共享</p>
<p>在java语言中：线程A和线程B，堆内存和方法区内存共享。但是栈内存独立，一个线程一个栈。</p>
</blockquote>
<p> <img src="http://qiniu-note-image.ctong.top/note/images/image-fcc7160104824cb5b20facbca02b58b5.png" alt="多线程内存结构图"></p>
</li>
<li><p>对于单核的CPU来说，真的可以做到真正的多线程并发吗？对于多核的CPU来说，真正的多线程并发是没问题的，4核CPU表示同一个时间点上，可以真正的有4个进程并发执行。</p>
<p><strong>什么是多线程并发？</strong></p>
<p>t1线程执行t1的，t2线程执行t2的，它们不会相互影响，这叫做真正的多线程并发。对于单核CPU来说，在某一个时间点上实际上只能处理一件事情，但是由于CPU的处理速度极快，多个线程之间频繁切换执行，给人的感觉是多个事情同时在做。</p>
<p><strong>单核CPU表示只有一个大脑：</strong></p>
<p>不能够做到真正的多线程并发，但是可以做到给人一种“多线程并发”的感觉。</p>
<blockquote>
<p>电影院采用交卷播放电影，一个交卷一个交卷播放速度达到一定程度之后，人类的眼睛产生了错觉，感觉是动画的，这说明人类的反应速度很慢。</p>
</blockquote>
</li>
</ol>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>java语言中，实现线程有两种方式</p>
<h3 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h3><p> 编写一个类，直接继承<strong>java.lang.Thread</strong>，重写<code>run</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">    <span class="comment">// 启动线程</span></span><br><span class="line">    myThread.start();</span><br><span class="line">    <span class="type">int</span> <span class="variable">forCount</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; forCount; i++) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;主线程打印=======》》》》&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">forCount</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; forCount; i++) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;分支线程打印=======》》》》&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>start() 方法的作用是：启动一个分支线程，在JVM中开辟一个新的栈空间，这段代码任务完成之后瞬间就结束了。这段代码的任务只是为了开辟一个新的栈空间，只要新的栈空间开出来，start() 方法就结束了，启动成功的线程会自动调用run方法，并且run方法在分支栈的栈底部（压栈）。run方法在 分支栈的栈底部，main方法在主栈的栈底部，它们两是平级的！</p>
<p><img src="http://qiniu-note-image.ctong.top/note/images/image-428c0fc525a94f668b2a9c194cfeba81.png" alt="执行结果"></p>
<h3 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h3><p>编写一个类实现java.lang.Runable接口<br> 这还只是一个可运行的类，它还不是一个线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 需要使用<code>Thread</code>封装成一个线程对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyRunnable</span> <span class="variable">myRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myRunnable);</span><br></pre></td></tr></table></figure>

<p>启动多线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第二种方式实现接口比较常用，因为一个类实现了接口，它还可以去继承其它的类，更灵活。</p>
</blockquote>
<h2 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h2><ol>
<li>新建状态</li>
<li>准备状态</li>
<li>运行状态</li>
<li>阻塞状态</li>
<li>死亡状态</li>
</ol>
<p><img src="http://qiniu-note-image.ctong.top/note/images/image-faad6930b5514002a557978eae51425e.png" alt="线程生命周期"></p>
<h2 id="获取线程对象名字"><a href="#获取线程对象名字" class="headerlink" title="获取线程对象名字"></a>获取线程对象名字</h2><p>现在有一个线程对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mt);</span><br></pre></td></tr></table></figure>

<p>设置它的名字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.setName(<span class="string">&quot;我的小线程！！&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>打印输出这个线程对象的名字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.getName()</span><br></pre></td></tr></table></figure>

<p>–  <code>我的小线程！！</code></p>
<p>如果不使用<code>setName</code>方法设置线程的名字，那么它也会有一个默认名字</p>
<p><strong>Thread-0</strong></p>
<p>这个默认线程的名字以**Thread-**与当前进程的线程数组成，这个线程数以0开始，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread-0、Thread-1、Thread-2、Thread-3</span><br></pre></td></tr></table></figure>



<h2 id="获取当前线程对象"><a href="#获取当前线程对象" class="headerlink" title="获取当前线程对象"></a>获取当前线程对象</h2><p>可以使用<code>Thread</code>对象中的<code>currentThread</code>方法来获取当前线程对象，这是一个静态方法，返回一个<code>Thread</code>对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; forCount; i++) &#123;</span><br><span class="line">  System.out.println(thread.getName() + <span class="string">&quot;=======》》》》&quot;</span> + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>– <code>我的小线程！！=======》》》》0</code></p>
<h2 id="线程的sleep方法"><a href="#线程的sleep方法" class="headerlink" title="线程的sleep方法"></a>线程的sleep方法</h2><p>关于线程的sleep方法：</p>
<p>static void sleep(long illis)</p>
<ol>
<li>静态方法</li>
<li>参数是毫秒</li>
<li>作用：让当前线程进入休眠，进入“阻塞状态”，放弃占有CPU时间片，让给其他线程使用。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">millis</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">5</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;准备开始睡眠！&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Thread.sleep(millis);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;线程休眠结束！！！&quot;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<p><code>t.sleep</code>会让线程<strong>t</strong>进入休眠状态吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">millis</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">5</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;准备开始睡眠！&quot;</span>);</span><br><span class="line">    <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myThread);</span><br><span class="line">    t.setName(<span class="string">&quot;t&quot;</span>);</span><br><span class="line">    t.start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      t.sleep(millis);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">forCount</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; forCount; i++) &#123;</span><br><span class="line">      System.out.println(thread.getName() + <span class="string">&quot;=======》》》》&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案是不会，因为<code>sleep</code>是<strong>静态方法</strong>，它跟对象没有半毛钱关系，在执行的时候还是会转换成 <code>Thread.sleep(millis)</code>，这行代码的作用是：让当前线程进入休眠状态，也就是说main线程会进入休眠状态。</p>
<h2 id="终止线程的睡眠"><a href="#终止线程的睡眠" class="headerlink" title="终止线程的睡眠"></a>终止线程的睡眠</h2><p>sleep睡眠太久了，如何唤醒一个正在睡眠的线程？</p>
<blockquote>
<p>run()当中的异常不能throws，只能try…catch。因为子类不能比父类抛出更多的异常。或者说重写之后的方法不能比重写之前的方法抛出更多（更宽泛）的异常，可以更少。run()方法在父类中没有抛出任何异常</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">TestSleep</span> <span class="variable">testSleep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestSleep</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(testSleep);</span><br><span class="line">    thread.setName(<span class="string">&quot;沉睡中的线程&quot;</span>);</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(<span class="string">&quot;5秒后叫醒沉睡的线程！！！&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">millis</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(millis);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在这里唤醒线程</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestSleep</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;进入沉睡！！&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">millis</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">365</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(millis);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;我被叫醒起来干活了！！&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h3><p>可以使用<code>interrupt</code>方法来终断线程，这种方式是依靠了java的异常处理机制来唤醒线程，相当于你在睡觉，我直接给你泼一盆冷水过去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread.interrupt();</span><br></pre></td></tr></table></figure>

<p>这个代码执行之后，<code>TestSleep</code>中的<code>Thread.sleep(millis);</code>受到了干扰出现了异常，这个异常被<code>try</code>抓住之后就被结束掉了，catch执行过后try…catch结束开始继续执行下边的代码。</p>
<p><img src="http://qiniu-note-image.ctong.top/note/images/image-17bec6a0476d4ec8ac96e6a1c300d90d.png" alt="interrupt执行结果"></p>
<h3 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h3><p>如果需要强行终止一个线程的执行，可以使用<code>stop</code>方法强行终止该线程（此方法已过时，不建议使用），这个stop不是终止线程睡眠，而是强制干掉指定线程。如果使用stop强行终止线程，则极大概率造成数据丢失、损坏等严重后果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">TestSleep</span> <span class="variable">testSleep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestSleep</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(testSleep);</span><br><span class="line">    thread.setName(<span class="string">&quot;执行中的线程&quot;</span>);</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(<span class="string">&quot;3秒后叫杀死线程！！！&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">millis</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(millis);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    thread.stop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestSleep</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">millis</span> <span class="operator">=</span> <span class="number">1000</span> ;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行中的线程-----&gt; &quot;</span> + i);</span><br><span class="line">        Thread.sleep(millis);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何合理的终止一个线程？</p>
<p>可以使用标记的方式结束一个正在执行的线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">TestSleep</span> <span class="variable">testSleep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestSleep</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(testSleep);</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(<span class="string">&quot;3秒后杀死线程！！！&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">millis</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(millis);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    testSleep.run = <span class="literal">false</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;thread kill&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestSleep</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个标记，用来结束这个线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="type">boolean</span> <span class="variable">run</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.run) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">millis</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">          System.out.println(<span class="string">&quot;执行-----&gt;&quot;</span> + i);</span><br><span class="line">          Thread.sleep(millis);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里处理结束线程之前需要执行的某些操作、例如保存数据等</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="线程调度概述"><a href="#线程调度概述" class="headerlink" title="线程调度概述"></a>线程调度概述</h2><ol>
<li><p>常见的线程调度模型有哪些？</p>
<ul>
<li>抢占式调度模型：哪个线程的优先级比较高，抢到的CPU时间片的概率就高一些&#x2F;多一些。java采用的就是抢占式调度模型。</li>
<li>均分式调度模型：平均分配CPU时间片。每个线程占有的CPU时间片时间长短一样。平均分配，一切平等。</li>
</ul>
</li>
<li><p>Java中提供了哪些方法是和线程调度有关系的呢？</p>
<ul>
<li><p>实例方法：</p>
<ol>
<li><p><code>void setPrioriry(int new Prioriry)</code>设置线程的优先级</p>
</li>
<li><p><code>int getPriority()</code>获取线程优先级,最低优先级1，默认优先级5，最高优先级是10，优先级比较高的获得CPU时间片可能比较多一些（但也不完全是，大概率是多的）。</p>
</li>
<li><p><code>void join()</code>合并线程，使当前线程进入阻塞状态，t线程执行，直到t线程结束，当前线程才可以继续执行，例如代码是这样的情况下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJoin</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyThread1</span> <span class="variable">myThread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myThread1);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      t.start();</span><br><span class="line">      t.join(); <span class="comment">// 使当前线程进入阻塞，t开始执行</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;main ----&gt; &quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;run ----&gt; &quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>静态方法</p>
<ol>
<li><p><code>static void yield()</code> 暂停当前正在执行的线程对象，并执行其他线程（让位方法）。yield方法不是阻塞方法，让当前线程让位，让给其他线程使用。yield方法的执行会让当前线程从<strong>“运行状态”</strong>回到<strong>“就绪状态”</strong></p>
<blockquote>
<p>回到就绪状态之后有可能还会再抢到时间片</p>
</blockquote>
<p><img src="http://qiniu-note-image.ctong.top/note/images/image-ac178fc547e84b62a87a0930a88cd6b0.png" alt="线程yield"></p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>关于线程的优先级</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;线程最大优先级：&quot;</span> + Thread.MAX_PRIORITY);</span><br><span class="line">System.out.println(<span class="string">&quot;线程默认优先级：&quot;</span> + Thread.NORM_PRIORITY);</span><br><span class="line">System.out.println(<span class="string">&quot;线程最小优先级：&quot;</span> + Thread.MIN_PRIORITY);</span><br></pre></td></tr></table></figure>

<p>– <code>线程最大优先级：10</code><br>– <code>线程默认优先级：5</code><br>– <code>线程最小优先级：1</code></p>
<p>设置进程优先级，优先级高的CPU时间片多一些，是指线程处于运行状态的时间多。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPriority</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thisThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    System.out.println(<span class="string">&quot;设置之前：&quot;</span> + thisThread.getPriority());</span><br><span class="line">    thisThread.setPriority(<span class="number">10</span>);</span><br><span class="line">    thisThread.getPriority();<span class="comment">// 当前线程优先级</span></span><br><span class="line">    System.out.println(<span class="string">&quot;设置之后：&quot;</span> + thisThread.getPriority());</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>– <code>设置之前：5</code><br>– <code>设置之后：10</code></p>
<h3 id="线程让位"><a href="#线程让位" class="headerlink" title="线程让位"></a>线程让位</h3><p>让位，当前线程暂停，回到就绪状态，让给其它线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.<span class="keyword">yield</span>();</span><br></pre></td></tr></table></figure>

<p>让位回到就绪状态之后，有可能还会抢到CPU时间片</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestYield</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">YieldThread</span> <span class="variable">yieldThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">YieldThread</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(yieldThread);</span><br><span class="line">    t.start();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i % <span class="number">100</span>) &#123;</span><br><span class="line">        Thread.<span class="keyword">yield</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;main ----&gt; &quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YieldThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;run ----&gt; &quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="http://qiniu-note-image.ctong.top/note/images/image-ac178fc547e84b62a87a0930a88cd6b0-20211227102835587.png" alt="线程生命周期-yield"></p>
<h3 id="合并线程"><a href="#合并线程" class="headerlink" title="合并线程"></a>合并线程</h3><p>join方法可以将<code>t</code>线程合并到当前线程中，当前线程受阻塞，<code>t</code>线程执行直到结束。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJoin</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyThread1</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;main thread start!&quot;</span>);</span><br><span class="line">    t.start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      t.join();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;main thread over!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;run ----&gt; &quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>– <code>main thread start!</code><br>– <code>run ----&gt; 0</code><br>– <code>run ----&gt; 1</code><br>– <code>run ----&gt; 2</code><br>– <code>main thread over!</code></p>
<blockquote>
<p>线程合并不是意味着两个线程合并成了一个线程，而是两个线程之前发生了等待关系。</p>
</blockquote>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><ol>
<li><p>为什么这个是重点？<br>以后在开发中，我们的项目都是运行在服务器当中，而服务器已经将线程对象的创建、线程的启动等，都已经实现完成了。这些代码都不需要编写。最重要的是我们要知道，我们编写的程序需要放到一个多线程的环境下运行，你更需要关注的是这些数据在多线程并发的环境下是否是安全的。</p>
</li>
<li><p>什么时候数据在多线程并发的环境下会存在安全问题？</p>
<ol>
<li>多线程并发</li>
<li>有共享数据</li>
<li>共享数据有修改的行为</li>
</ol>
<p>满足以上三个条件之后就会存在线程安全问题。</p>
<p><img src="http://qiniu-note-image.ctong.top/note/images/image-ffd3735a179643adb0831bdf779b1f11.png" alt="造成线程安全原理图"></p>
<iframe src="//player.bilibili.com/player.html?aid=93347594&bvid=BV1mE411x7Wt&cid=163966574&page=305" scrolling="no" width="100%" style='height: -webkit-fill-available' border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
</li>
<li><p>怎么解决线程安全问题呢？</p>
<p>当多线程并发的环境下，有共享数据，并且这个数据还会被修改，此时就存在线程安全问题，怎么解决这个问题？</p>
<ul>
<li><p>线程排队执行。（不能并发）。用排队执行解决线程安全问题，这种机制被称为：线程同步机制。</p>
</li>
<li><p>专业术语叫做：线程同步，实际上就是线程不能并发了，线程必须排队执行。</p>
</li>
<li><p>使用<strong>线程线程同步机制</strong>解决这个问题，线程同步就是线程排队了，线程排队了就会牺牲一部分效率</p>
</li>
</ul>
</li>
<li><p>说到线程同步这块，涉及到这两个专业术语：</p>
<ul>
<li>异步编程模型：<br>线程t1和线程t2，各自执行各自的，t1不管t2，t2不管t1，谁也不需要等谁，这种编程模型叫做：异步编程模型。其实就是：多线程并发（效率较高。）</li>
<li>同步编程模型：<br>线程t1和线程t2，在线程t1执行的时候，必须等待t2执行结束，或者说在t2线程执行的时候，必须等待t1线程执行结束，两个线程之间发生了等待关系，这就是同步编程模型，效率较低。线程排队执行</li>
</ul>
</li>
</ol>
<h3 id="synchronized-关键字-–-线程同步机制"><a href="#synchronized-关键字-–-线程同步机制" class="headerlink" title="synchronized 关键字 – 线程同步机制"></a>synchronized 关键字 – 线程同步机制</h3><p>线程同步的语法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> () &#123;</span><br><span class="line">  <span class="comment">// 线程同步代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>synchronized后面小括号中传的这个数据是相当关键的。这个数据必须是多线程共享的数据。才能达到多线程排队。小括号中写什么那主要是看你想要哪些线程同步了。</p>
<p>假有：t1、t2、t3、t4、t5，有五个线程，你只希望t1、t2、t3排队，t4、t5不需要排队怎么办？</p>
<ul>
<li><p>只需要在小括号中写一个：t1、t2、t3共享的对象。而这个对象对t4、t5来说不是共享的。</p>
<p>例如有一个账户类，类中的金额这个数据是共享的，这个类还有一个取款方法（<code>withbraw</code>中加<code>sleep</code>是为了模拟网络延迟）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">double</span> <span class="variable">balance</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String Name;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    Name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> balance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBalance</span><span class="params">(<span class="type">double</span> balance)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.balance = balance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取款</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withbraw</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">      <span class="type">double</span> <span class="variable">before</span> <span class="operator">=</span> getBalance();</span><br><span class="line">      <span class="type">double</span> <span class="variable">after</span> <span class="operator">=</span> before - money;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      setBalance(after);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于以上程序来说，这是相当危险的操作，因为<code>sleep</code>模拟网络延迟之后，无法调用<code>setBalance</code>方法去修改金额，第二个线程进来的时候金额还是<code>1000</code>，导致两个人对同一个账户取款5000时还剩下5000，如果加上线程同步就不会发生这种问题，因为某个线程在执行的时候其他线程在后面排队</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withbraw</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> <span class="variable">before</span> <span class="operator">=</span> getBalance();</span><br><span class="line">    <span class="type">double</span> <span class="variable">after</span> <span class="operator">=</span> before - money;</span><br><span class="line">    setBalance(after);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在java语言中，任何一个对象都有**”一把锁”**，其实这把锁就是一个标记。(只是把它叫做锁)，100个对象100把锁，一个对象一把锁。</p>
</li>
<li><p>以上代码的执行原理？</p>
<ol>
<li>假设t1和t2线程并发，开始执行以上代码的时候，肯定有一个先一个后。</li>
<li>假设t1先执行了，遇到了<code>synchronized</code>的时候自动找“后面共享对象”的对象锁，找到之后，并占有这把锁，然后执行同步代码块中的程序，在程序执行过程中占有这把锁的。直到同步代码块执行结束，这把锁才会释放。</li>
<li>假设t1已经占有这把锁，此时t2也遇到了<code>synchronized</code>关键字，也会去占有后面共享对象的这把锁，结果这把锁被t1占有，t2只能在同步代码块外面等待t1的结束，直到t1把同步代码块执行结束，t1会归还这把锁，此时t2终于等到这把锁，然后t2占有这把锁之后，进入同步代码执行程序。</li>
</ol>
<blockquote>
<p>这样就达到了线程排队执行</p>
<p>这里需要注意的是：这个共享对象一定要选好。这个共享对象一定是你需要排队执行的这些线程对象共享的。</p>
</blockquote>
<p><img src="http://qiniu-note-image.ctong.top/note/images/image-1b76c2ef7b0a43c5bb7e1e814cb23ec1.png" alt="线程生命周期-synchronized"></p>
<ol start="4">
<li><p>Java中有三大变量？</p>
<ul>
<li>实例变量：在堆中</li>
<li>静态变量：在方法区</li>
<li>局部变量：在栈中</li>
</ul>
<blockquote>
<p>以上三大变量中，局部变量永远都不会存在线程安全问题。因为局部变量不共享。一个线程一个栈，局部变量在栈中。</p>
<p>实例变量在堆中，堆只有一个。</p>
<p>静态变量在方法区中，方法区只有一个。</p>
<p>堆和方法区都是多线程共享的，所以可能存在线程安全问题。</p>
</blockquote>
</li>
<li><p>同步代码块越小效率越高。</p>
</li>
<li><p>在实例方法上可以使用<code>synchronized</code><br>synchronized出现在实例方法上，一定锁的是this，也只能是this。不能再是其他对象了，所以这种方式不灵活。</p>
<p>另外还有一个缺点：synchronized出现在实例方法上，表示整个方法体都需要同步，可能会无故扩大同步的范围，导致程序的执行效率降低。所以这种方式不常用</p>
</li>
<li><p>synchronized有三种写法：</p>
<ul>
<li><p>同步代码块，比较灵活</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(线程共享对象) &#123;</span><br><span class="line">  同步代码块;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在实例方法上使用synchronized</p>
<p>表示共享对象一定是this，并且同步代码块是整个方法体。</p>
</li>
<li><p>在静态方法上使用synchronized<br>表示找类锁<br>类锁永远只有一把，就算创建了100个对象，那类锁也只有一把。</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h2><p>死锁会导致程序不出异常，也不会出现错误，程序一直僵持在那里，这种错误最难调试。</p>
<h3 id="死锁简单代码"><a href="#死锁简单代码" class="headerlink" title="死锁简单代码"></a>死锁简单代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLock</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="type">MyThread2</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread2</span>(o1, o2);</span><br><span class="line">    <span class="type">MyThread3</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread3</span>(o1, o2);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">  Object o1;</span><br><span class="line">  Object o2;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MyThread2</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.o1 = o1;</span><br><span class="line">    <span class="built_in">this</span>.o2  = o2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyThread2&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread3</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">  Object o1;</span><br><span class="line">  Object o2;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MyThread3</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.o1 = o1;</span><br><span class="line">    <span class="built_in">this</span>.o2  = o2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyThread3&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>synchronized在开发中最好不要嵌套使用，一不小心就可能导致死锁现象发生。</p>
</blockquote>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>在开发中是一上来就选择线程同步吗？synchronized，不是，synchronized会让程序执行效率降低，用户体验不好。 </p>
<ol>
<li>尽量使用局部变量来代替“实例变量和静态变量”</li>
<li>如果必须是实例变量，那么可以考虑创建多个对象，这样实例变量的内存就不共享里。（一个线程对应一个对象，100个线程对应100个对象，对象不共享，就没有数据安全问题了。）</li>
<li>如果不能使用局部变量，对象也不能创建多个，这个时候就只能选择synchronized了，线程同步机制。</li>
</ol>
<h2 id="线程相关内容"><a href="#线程相关内容" class="headerlink" title="线程相关内容"></a>线程相关内容</h2><ol>
<li><p>守护线程</p>
<p>Java语言中线程分为两大类：</p>
<ol>
<li><p>用户线程</p>
<p>主线程<code>main</code>方法是一个用户线程。</p>
</li>
<li><p>守护线程（后台线程）<br>其中具有代表性的就是：gc垃圾回收线程。</p>
<h4 id="守护线程的特点"><a href="#守护线程的特点" class="headerlink" title="守护线程的特点"></a>守护线程的特点</h4><p>一般守护线程是一个死循环，所有的用户线程只要结束，守护线程自动结束。</p>
<h4 id="守护线程用在什么地方呢？"><a href="#守护线程用在什么地方呢？" class="headerlink" title="守护线程用在什么地方呢？"></a>守护线程用在什么地方呢？</h4><p>守护线程的目的是守护，比如每天00:00的时候系统数据自动备份，这个需要使用到定时器，并且我们可以将定时器设置为守护线程。一直在那里看着，每到00:00的时候开始备份一次。</p>
<h4 id="设置守护线程"><a href="#设置守护线程" class="headerlink" title="设置守护线程"></a>设置守护线程</h4><p>在启动之前将线程设置为守护线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(...);</span><br><span class="line">t.setDaemon(<span class="literal">true</span>);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<p>即使是死循环，但由于该线程是守护者，当用户线程结束，守护线程自动终止。</p>
</li>
</ol>
</li>
<li><p>定时器<br>间隔特定的时间去做特定的事。</p>
<p>比如每周要进行银行账户的总帐操作。每天要进行数据的备份操作。在实际开发中，每隔多久执行一段特定的程序，这种需求是很常见的，那么在java中其实可以采用很多种方法实现</p>
<ol>
<li>可以使用sleep方法，睡眠，设置睡眠时间，每到这个点醒来，执行任务，这种方式是最原始的。</li>
<li>在java的类库中已经写好了一个定时器：java.util.Timer，不过这种方式在目前的开发中也很少用，因为现在有很多高级框架都是支持定时任务的。</li>
</ol>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestTimer</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">logTimerTask</span> <span class="variable">logTimerTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">logTimerTask</span>();</span><br><span class="line">    <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(<span class="string">&quot;记录日志&quot;</span>);</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-d HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">Date</span> <span class="variable">da</span> <span class="operator">=</span> sdf.parse(<span class="string">&quot;2020-11-03 23:52:00&quot;</span>);</span><br><span class="line">      timer.schedule(logTimerTask,da, <span class="number">1000</span> * <span class="number">10</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">logTimerTask</span> <span class="keyword">extends</span> <span class="title class_">TimerTask</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;开始记录！&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>实现线程的第三种方式：FutrueTask方式，实现Callable接口。（JDK8新特性）<br>这种方式实现的线程可以获取线程的返回值，之前写的那几种方式是无法获取线程的返回值，因为run方法返回void</p>
<h4 id="实现线程的第三种方式"><a href="#实现线程的第三种方式" class="headerlink" title="实现线程的第三种方式"></a>实现线程的第三种方式</h4><p>创建一个未来任务类对象</p>
<p><code>java.util.concurrent.FutureTask</code>JUC包下的，属于java的并发包，老JDK中没有这个包。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FutureTask</span> <span class="variable">ft</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(<span class="keyword">new</span> <span class="title class_">Callable</span>() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// call 方法就相当于run方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>使用这个未来任务类对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FutureTask</span> <span class="variable">ft</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(...);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<p>使用FutureTask中的get方法来获取线程的返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FutureTask</span> <span class="variable">ft</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(...);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft);</span><br><span class="line">t.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  ft.get();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用get方法之后会阻塞当前线程，而get方法可能需要很久。因为get方法是为了拿另一个线程的执行结果，另一个线程执行是需要时间的。</strong></p>
</li>
<li><p>关于Object类中的wait和notify方法（生产者和消费者模式）</p>
<ul>
<li><p>wait和notify不是线程对象的方法，是java中任何一个对象都有的方法，因为这两个方法是Object类中自带的。</p>
</li>
<li><p>wait方法的作用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Obect</span>();</span><br><span class="line">o.wait();</span><br></pre></td></tr></table></figure>

<p>表示让正在o对象上活动的线程进入等待状态，无期限等待，直到被唤醒为止。（当前线程）</p>
<p><strong>o.wait();方法会让正在o对象上活动的当前线程对象进入等待状态，并且释放之前占有的o对象的锁</strong></p>
</li>
<li><p>notify方法的作用</p>
<p>T线程在o线程上活动，T线程是当前线程对象。当调用o.wait方法之后。T线程进入无期限等待。当前线程进入等待状态，直到最终调用notify方法。o.notify方法的调用可以让正在o对象上等待的线程唤醒。<br><code>o.notify();</code></p>
<p><strong>表示唤醒正在o对象上等待的线程。</strong></p>
</li>
</ul>
<h3 id="生产者和消费者"><a href="#生产者和消费者" class="headerlink" title="生产者和消费者"></a>生产者和消费者</h3><p>生产者和消费者模式是为了专门解决某个特定需求的。</p>
<p>一个线程负责生产，一个线程负责消费，而且还要达到生产和消费必须均衡。例如：</p>
<p>生产满了，就不能再继续生产了，必须让消费线程进行消费。消费完了，就不能消费了，必须让生产线程进行生产</p>
<blockquote>
<p>wait方法和notify方法建立在synchronized线程同步的基础之上。</p>
</blockquote>
</li>
</ol>
<p> <a target="_blank" rel="noopener" href="https://github.com/Clover-You/my-blog-file/blob/main/%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%BB%A3%E7%A0%81.zip">点击下载「生产者和消费者模式」的学习代码</a></p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">首页</a></li>
        
          <li><a href="/about/">关于</a></li>
        
          <li><a href="/archives/">归档</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">什么是进程？什么是线程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">2.1.</span> <span class="toc-text">第一种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">第二种方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.</span> <span class="toc-text">线程生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8B%E5%AF%B9%E8%B1%A1%E5%90%8D%E5%AD%97"><span class="toc-number">4.</span> <span class="toc-text">获取线程对象名字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.</span> <span class="toc-text">获取当前线程对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84sleep%E6%96%B9%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">线程的sleep方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%9D%A1%E7%9C%A0"><span class="toc-number">7.</span> <span class="toc-text">终止线程的睡眠</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#interrupt"><span class="toc-number">7.1.</span> <span class="toc-text">interrupt</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stop"><span class="toc-number">7.2.</span> <span class="toc-text">stop</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A6%82%E8%BF%B0"><span class="toc-number">8.</span> <span class="toc-text">线程调度概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">8.1.</span> <span class="toc-text">线程优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%AE%A9%E4%BD%8D"><span class="toc-number">8.2.</span> <span class="toc-text">线程让位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E7%BA%BF%E7%A8%8B"><span class="toc-number">8.3.</span> <span class="toc-text">合并线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">9.</span> <span class="toc-text">线程安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized-%E5%85%B3%E9%94%AE%E5%AD%97-%E2%80%93-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">9.1.</span> <span class="toc-text">synchronized 关键字 – 线程同步机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81"><span class="toc-number">10.</span> <span class="toc-text">线程死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%AE%80%E5%8D%95%E4%BB%A3%E7%A0%81"><span class="toc-number">10.1.</span> <span class="toc-text">死锁简单代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">10.2.</span> <span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9"><span class="toc-number">11.</span> <span class="toc-text">线程相关内容</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">11.0.1.</span> <span class="toc-text">守护线程的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E7%94%A8%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9%E5%91%A2%EF%BC%9F"><span class="toc-number">11.0.2.</span> <span class="toc-text">守护线程用在什么地方呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-number">11.0.3.</span> <span class="toc-text">设置守护线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">11.0.4.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AC%AC%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">11.0.5.</span> <span class="toc-text">实现线程的第三种方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">11.1.</span> <span class="toc-text">生产者和消费者</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://www.ctong.top/2022/01/02/40%E3%80%81Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://www.ctong.top/2022/01/02/40%E3%80%81Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/&text=40、Java 多线程"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://www.ctong.top/2022/01/02/40%E3%80%81Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/&title=40、Java 多线程"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://www.ctong.top/2022/01/02/40%E3%80%81Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/&is_video=false&description=40、Java 多线程"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=40、Java 多线程&body=Check out this article: http://www.ctong.top/2022/01/02/40%E3%80%81Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://www.ctong.top/2022/01/02/40%E3%80%81Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/&title=40、Java 多线程"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://www.ctong.top/2022/01/02/40%E3%80%81Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/&title=40、Java 多线程"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://www.ctong.top/2022/01/02/40%E3%80%81Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/&title=40、Java 多线程"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://www.ctong.top/2022/01/02/40%E3%80%81Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/&title=40、Java 多线程"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://www.ctong.top/2022/01/02/40%E3%80%81Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/&name=40、Java 多线程&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://www.ctong.top/2022/01/02/40%E3%80%81Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/&t=40、Java 多线程"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2023
    Clover You
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
